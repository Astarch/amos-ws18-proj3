## Spring Elastic Search
In order to add Elastic Search functionality to Spring, we will describe shortly how to create a data model class, a data access object and how to configure sping for (internal and external nodes).

In addition to that, we will provide a brief look on how to create simple requests, some more complex custom requests and aggregations.

### Setup
#### Maven dependency
```
<dependency>
	<groupId>org.springframework.data</groupId>
	<artifactId>spring-data-elasticsearch</artifactId>
	<version>3.0.2.RELEASE</version> <!-- or whatever version you prefer -->
</dependency>
```
Find you preferred version here: https://mvnrepository.com/artifact/org.springframework.data/spring-data-elasticsearch

### Model
Create a model class. Annotate the class with `@Document(indexName = "yourindex", type = "yourtype")`. The `index` is very important here, it will be used to identify the "table" we know from relational databases. If you change the index on a running instance, older entries will not be found anymore. If you import data using the new index and then switching back to the older one, any recently added data using the new index will not be found anymore.

Annotate one of the member variables of the class with `@Id` to mark this field as the identifier of the entity. The ID behaves like we know it from relational databases. It can also be used to find, delete or overwrite data.

Annotate the remaining fields with a proper `@Field` annotation. You should provide `type` in order to define the data type of the field and `index` in order to specify how the field should be indexed (making it searchable). You can also define more complex data types such as:
```
    @Field(type = FieldType.Date, index = FieldIndex.not_analyzed, store = true, format = DateFormat.custom, pattern = "yyyyMMddHHmmss")
    private String dateadded;
```
This is a simple string in Java, but ES will iterpret it as a date by the given format. ES will tell you, if you mess up with the dates. E.g. '20170231000005', which is five past midnight on february 31st 2017, will lead to an error because february ends at the 28th.

Have a look at https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html and https://docs.spring.io/spring-data/elasticsearch/docs/current/api/org/springframework/data/elasticsearch/annotations/Field.html for more details.

An example class could look like this:
```
    import org.springframework.data.annotation.Id;
    import org.springframework.data.elasticsearch.annotations.DateFormat;
    import org.springframework.data.elasticsearch.annotations.Document;
    import org.springframework.data.elasticsearch.annotations.Field;
    import org.springframework.data.elasticsearch.annotations.FieldIndex;
    import org.springframework.data.elasticsearch.annotations.FieldType;
    
    @Document(indexName = "article-2018.01.18", type = "csv")
    public class Article {
    	@Id
    	private String globaleventid;
    	@Field(type = FieldType.String, index = FieldIndex.analyzed)
    	private String sourceurl;
    	@Field(type = FieldType.Date, index = FieldIndex.not_analyzed, store = true, format = DateFormat.custom, pattern = "yyyyMMddHHmmss")
    	private String dateadded;
    }
```

### Data Access
One the model is created, we need a connection to an Elastic Search node (or cluster of nodes).
First of all, we need a repository for that. Spring will take care of this, if you define an Interface like this:
```
    import org.springframework.data.elasticsearch.repository.ElasticsearchRepository;
    import <Article>;
    
    public interface ArticleDAO extends ElasticsearchRepository<Article, String> {
    }
```
`ArticleDAO` can be autowired and be used like any Spring Bean. The basic funtionality will be provided using several methods autogenerated by Spring. 
* `findAll();`
* `findOne(String id);`
* `save(Article a);`
* `save(Iterable<Article> a);`
* `delete(Article a);`
* etc ...

If no further configuration is done, Spring will run an Elastic Search node itself, the data will be stored in a folder *data* at project root location. In order to specify external node(s), we need to adapt the application.properties.
```
    spring.data.elasticsearch.cluster-name=myElasticInstance
    spring.data.elasticsearch.cluster-nodes=1.2.3.4:9300, 1.2.3.5:9300
    spring.data.elasticsearch.repositories.enabled=true
    spring.data.elasticsearch.properties.node.local=false
    spring.data.elasticsearch.properties.node.data=false
    spring.data.elasticsearch.properties.http.enabled=true
```

### Simple Queries
Some simple queries can be created simply by adding the corresponding syntactically correct named method to the DAO. For the Article example above, we could define a method like `List<Article> findAllBySourceurlContainingIgnoreCase(String s);` in the `ArticleDAO`. Spring will iterpret the name of the method and create a query on its own in order to retrieve entities containing the (ignore case) string s in its *sourceurl*-field.

### Complex Queries
In order to perform more complex queries, there are several ways to do that.
Beginning with the most convinient one, but also not so powerful way, we will annotate a method with a json query.
```
	@Query("{\"bool\": {\"must\": [{\"match\": {\"dateadded\": \"?0\"}}]}}")
	Page<Article> findAllByMyOwnCustomQueryAnnotation(String date, Pageable pageable);
```
The annotation contains a JSON Elastic Seach Query, which will match the date field for the given parameter. Spring will match the first parameter (index 0) with the `?0` in the annotated query.
The second parameter can be used in any Spring related JPA, and provides pagination.

Another, more powerful way is to create queries using the Spring Elastic Search Querybuilders.
In order to do that, we need an ElasticSearchTemplate Bean, which can be retrieved by adding tho following to you application configuration:
```
	@Bean
	public ElasticsearchOperations elasticsearchTemplate() {
		ElasticsearchTemplate et = new ElasticsearchTemplate(nodeBuilder().local(true).node().client());
		et.putMapping(Article.class);
		return et;
	}
```
The ElasticSearchTemplate/ElasticsearchOperation can be autowired anywhere usingin the Spring context.
You can now create queries in your business layer and perform them on the DAO.
```
        import static org.elasticsearch.index.query.QueryBuilders.regexpQuery;
        ...
		SearchQuery searchQuery = new NativeSearchQueryBuilder().withFilter(regexpQuery("sourceurl", regEx)).build();
		List<Article> articles = elasticsearchOperations.queryForList(searchQuery, Article.class);
		return articles;
```
The example above creates a `SearchQuery` that filters the *sourceurl* column for a given regular expression *regEx*. Having a look at the static imports of `org.elasticsearch.index.query.QueryBuilders` might help to perform  your custom request.

### Aggregations
Performing aggregations on ES is more complex. Queries tend to look messy and may become quite long. This is also the case for performing the same query using JSON requests. So lets dig into it.
In the following example, we want know how many articles concerning a certain topic were released at individual dates. So we are going to perform a filter by term, in order to find all relevant articles. These articles have to be aggregated by date (`year`, `month` and `day` as individual fields of `Article`).

```
// create search query with aggregations
		SearchQuery aSearchQuery = new NativeSearchQueryBuilder()
				.withQuery(
					buildSearchQuery(topic) // your custom filter query comes here
				)
				.withIndices("article-2018.01.18")
				.withTypes("csv")
				.addAggregation(
					terms("byYear")
					.field("year")
					.size(10)
					.order(Order.term(true))
					.subAggregation(
						terms("byMonth")
						.field("month")
						.size(12)
						.order(Order.term(true))
						.subAggregation(
							terms("byDay")
							.field("day")
							.size(31)
							.order(Order.term(true))
						)
					)
				)
				.build();

// execute aggregation
		Aggregations aggregations = elasticsearchOperations.query(aSearchQuery,
				new ResultsExtractor<Aggregations>() {
					@Override
					public Aggregations extract(SearchResponse aResponse) {
						return aResponse.getAggregations();
					}
				});
				
// iterate aggregation
		Terms yearTerms = aggregations.get("byYear");
		yearTerms.getBuckets().stream().forEach(yearBucket -> {
			Object yearValue = yearBucket.getKey();
			Terms monthTerms = yearBucket.getAggregations().get("byMonth");

			monthTerms.getBuckets().stream().forEach(monthBucket -> {
				Object monthValue = monthBucket.getKey();
				Terms dayTerms = monthBucket.getAggregations().get("byDay");

				dayTerms.getBuckets().stream().forEach(dayBucket -> {
					Object dayValue = dayBucket.getKey();
					
					// do what you like here
					Long count = dayBucket.getDocCount();
					log.debug(yearValue.toString() + monthValue.toString() +  dayValue.toString() + " = " + count);
				});
			});
		});
```
